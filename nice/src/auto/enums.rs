// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../gir-files
// DO NOT EDIT

use glib::translate::*;
use glib::value::FromValue;
use glib::value::ToValue;
use glib::StaticType;
use glib::Type;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NiceCandidateTransport")]
pub enum CandidateTransport {
    #[doc(alias = "NICE_CANDIDATE_TRANSPORT_UDP")]
    Udp,
    #[doc(alias = "NICE_CANDIDATE_TRANSPORT_TCP_ACTIVE")]
    TcpActive,
    #[doc(alias = "NICE_CANDIDATE_TRANSPORT_TCP_PASSIVE")]
    TcpPassive,
    #[doc(alias = "NICE_CANDIDATE_TRANSPORT_TCP_SO")]
    TcpSo,
#[doc(hidden)]
    __Unknown(i32),
}

impl CandidateTransport {
    #[cfg(any(feature = "v0_1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_18")))]
    #[doc(alias = "nice_candidate_transport_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(self) -> Option<glib::GString> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::nice_candidate_transport_to_string(self.into_glib()))
        }
    }
}

impl fmt::Display for CandidateTransport {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "CandidateTransport::{}", match *self {
            Self::Udp => "Udp",
            Self::TcpActive => "TcpActive",
            Self::TcpPassive => "TcpPassive",
            Self::TcpSo => "TcpSo",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for CandidateTransport {
    type GlibType = ffi::NiceCandidateTransport;

    fn into_glib(self) -> ffi::NiceCandidateTransport {
        match self {
            Self::Udp => ffi::NICE_CANDIDATE_TRANSPORT_UDP,
            Self::TcpActive => ffi::NICE_CANDIDATE_TRANSPORT_TCP_ACTIVE,
            Self::TcpPassive => ffi::NICE_CANDIDATE_TRANSPORT_TCP_PASSIVE,
            Self::TcpSo => ffi::NICE_CANDIDATE_TRANSPORT_TCP_SO,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NiceCandidateTransport> for CandidateTransport {
    unsafe fn from_glib(value: ffi::NiceCandidateTransport) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Self::Udp,
            1 => Self::TcpActive,
            2 => Self::TcpPassive,
            3 => Self::TcpSo,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for CandidateTransport {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nice_candidate_transport_get_type()) }
    }
}

impl glib::value::ValueType for CandidateTransport {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for CandidateTransport {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CandidateTransport {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NiceCandidateType")]
pub enum CandidateType {
    #[doc(alias = "NICE_CANDIDATE_TYPE_HOST")]
    Host,
    #[doc(alias = "NICE_CANDIDATE_TYPE_SERVER_REFLEXIVE")]
    ServerReflexive,
    #[doc(alias = "NICE_CANDIDATE_TYPE_PEER_REFLEXIVE")]
    PeerReflexive,
    #[doc(alias = "NICE_CANDIDATE_TYPE_RELAYED")]
    Relayed,
#[doc(hidden)]
    __Unknown(i32),
}

impl CandidateType {
    #[cfg(any(feature = "v0_1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_18")))]
    #[doc(alias = "nice_candidate_type_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(self) -> Option<glib::GString> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::nice_candidate_type_to_string(self.into_glib()))
        }
    }
}

impl fmt::Display for CandidateType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "CandidateType::{}", match *self {
            Self::Host => "Host",
            Self::ServerReflexive => "ServerReflexive",
            Self::PeerReflexive => "PeerReflexive",
            Self::Relayed => "Relayed",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for CandidateType {
    type GlibType = ffi::NiceCandidateType;

    fn into_glib(self) -> ffi::NiceCandidateType {
        match self {
            Self::Host => ffi::NICE_CANDIDATE_TYPE_HOST,
            Self::ServerReflexive => ffi::NICE_CANDIDATE_TYPE_SERVER_REFLEXIVE,
            Self::PeerReflexive => ffi::NICE_CANDIDATE_TYPE_PEER_REFLEXIVE,
            Self::Relayed => ffi::NICE_CANDIDATE_TYPE_RELAYED,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NiceCandidateType> for CandidateType {
    unsafe fn from_glib(value: ffi::NiceCandidateType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Self::Host,
            1 => Self::ServerReflexive,
            2 => Self::PeerReflexive,
            3 => Self::Relayed,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for CandidateType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nice_candidate_type_get_type()) }
    }
}

impl glib::value::ValueType for CandidateType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for CandidateType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CandidateType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NiceCompatibility")]
pub enum Compatibility {
    #[doc(alias = "NICE_COMPATIBILITY_RFC5245")]
    Rfc5245,
    #[doc(alias = "NICE_COMPATIBILITY_GOOGLE")]
    Google,
    #[doc(alias = "NICE_COMPATIBILITY_MSN")]
    Msn,
    #[doc(alias = "NICE_COMPATIBILITY_WLM2009")]
    Wlm2009,
    #[doc(alias = "NICE_COMPATIBILITY_OC2007")]
    Oc2007,
    #[doc(alias = "NICE_COMPATIBILITY_OC2007R2")]
    Oc2007r2,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Compatibility {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Compatibility::{}", match *self {
            Self::Rfc5245 => "Rfc5245",
            Self::Google => "Google",
            Self::Msn => "Msn",
            Self::Wlm2009 => "Wlm2009",
            Self::Oc2007 => "Oc2007",
            Self::Oc2007r2 => "Oc2007r2",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for Compatibility {
    type GlibType = ffi::NiceCompatibility;

    fn into_glib(self) -> ffi::NiceCompatibility {
        match self {
            Self::Rfc5245 => ffi::NICE_COMPATIBILITY_RFC5245,
            Self::Google => ffi::NICE_COMPATIBILITY_GOOGLE,
            Self::Msn => ffi::NICE_COMPATIBILITY_MSN,
            Self::Wlm2009 => ffi::NICE_COMPATIBILITY_WLM2009,
            Self::Oc2007 => ffi::NICE_COMPATIBILITY_OC2007,
            Self::Oc2007r2 => ffi::NICE_COMPATIBILITY_OC2007R2,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NiceCompatibility> for Compatibility {
    unsafe fn from_glib(value: ffi::NiceCompatibility) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Self::Rfc5245,
            1 => Self::Google,
            2 => Self::Msn,
            3 => Self::Wlm2009,
            4 => Self::Oc2007,
            5 => Self::Oc2007r2,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for Compatibility {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nice_compatibility_get_type()) }
    }
}

impl glib::value::ValueType for Compatibility {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for Compatibility {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for Compatibility {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NiceComponentState")]
pub enum ComponentState {
    #[doc(alias = "NICE_COMPONENT_STATE_DISCONNECTED")]
    Disconnected,
    #[doc(alias = "NICE_COMPONENT_STATE_GATHERING")]
    Gathering,
    #[doc(alias = "NICE_COMPONENT_STATE_CONNECTING")]
    Connecting,
    #[doc(alias = "NICE_COMPONENT_STATE_CONNECTED")]
    Connected,
    #[doc(alias = "NICE_COMPONENT_STATE_READY")]
    Ready,
    #[doc(alias = "NICE_COMPONENT_STATE_FAILED")]
    Failed,
#[doc(hidden)]
    __Unknown(i32),
}

impl ComponentState {
    #[cfg(any(feature = "v0_1_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_6")))]
    #[doc(alias = "nice_component_state_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(self) -> Option<glib::GString> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::nice_component_state_to_string(self.into_glib()))
        }
    }
}

impl fmt::Display for ComponentState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "ComponentState::{}", match *self {
            Self::Disconnected => "Disconnected",
            Self::Gathering => "Gathering",
            Self::Connecting => "Connecting",
            Self::Connected => "Connected",
            Self::Ready => "Ready",
            Self::Failed => "Failed",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for ComponentState {
    type GlibType = ffi::NiceComponentState;

    fn into_glib(self) -> ffi::NiceComponentState {
        match self {
            Self::Disconnected => ffi::NICE_COMPONENT_STATE_DISCONNECTED,
            Self::Gathering => ffi::NICE_COMPONENT_STATE_GATHERING,
            Self::Connecting => ffi::NICE_COMPONENT_STATE_CONNECTING,
            Self::Connected => ffi::NICE_COMPONENT_STATE_CONNECTED,
            Self::Ready => ffi::NICE_COMPONENT_STATE_READY,
            Self::Failed => ffi::NICE_COMPONENT_STATE_FAILED,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NiceComponentState> for ComponentState {
    unsafe fn from_glib(value: ffi::NiceComponentState) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Self::Disconnected,
            1 => Self::Gathering,
            2 => Self::Connecting,
            3 => Self::Connected,
            4 => Self::Ready,
            5 => Self::Failed,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for ComponentState {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nice_component_state_get_type()) }
    }
}

impl glib::value::ValueType for ComponentState {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ComponentState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ComponentState {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NiceComponentType")]
pub enum ComponentType {
    #[doc(alias = "NICE_COMPONENT_TYPE_RTP")]
    Rtp,
    #[doc(alias = "NICE_COMPONENT_TYPE_RTCP")]
    Rtcp,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ComponentType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "ComponentType::{}", match *self {
            Self::Rtp => "Rtp",
            Self::Rtcp => "Rtcp",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for ComponentType {
    type GlibType = ffi::NiceComponentType;

    fn into_glib(self) -> ffi::NiceComponentType {
        match self {
            Self::Rtp => ffi::NICE_COMPONENT_TYPE_RTP,
            Self::Rtcp => ffi::NICE_COMPONENT_TYPE_RTCP,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NiceComponentType> for ComponentType {
    unsafe fn from_glib(value: ffi::NiceComponentType) -> Self {
        skip_assert_initialized!();
        match value {
            1 => Self::Rtp,
            2 => Self::Rtcp,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for ComponentType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nice_component_type_get_type()) }
    }
}

impl glib::value::ValueType for ComponentType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ComponentType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ComponentType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v0_1_15", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NiceNominationMode")]
pub enum NominationMode {
    #[doc(alias = "NICE_NOMINATION_MODE_REGULAR")]
    Regular,
    #[doc(alias = "NICE_NOMINATION_MODE_AGGRESSIVE")]
    Aggressive,
#[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v0_1_15", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
impl fmt::Display for NominationMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "NominationMode::{}", match *self {
            Self::Regular => "Regular",
            Self::Aggressive => "Aggressive",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v0_1_15", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
#[doc(hidden)]
impl IntoGlib for NominationMode {
    type GlibType = ffi::NiceNominationMode;

    fn into_glib(self) -> ffi::NiceNominationMode {
        match self {
            Self::Regular => ffi::NICE_NOMINATION_MODE_REGULAR,
            Self::Aggressive => ffi::NICE_NOMINATION_MODE_AGGRESSIVE,
            Self::__Unknown(value) => value,
}
    }
}

#[cfg(any(feature = "v0_1_15", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
#[doc(hidden)]
impl FromGlib<ffi::NiceNominationMode> for NominationMode {
    unsafe fn from_glib(value: ffi::NiceNominationMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Self::Regular,
            1 => Self::Aggressive,
            value => Self::__Unknown(value),
}
    }
}

#[cfg(any(feature = "v0_1_15", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
impl StaticType for NominationMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nice_nomination_mode_get_type()) }
    }
}

#[cfg(any(feature = "v0_1_15", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
impl glib::value::ValueType for NominationMode {
    type Type = Self;
}

#[cfg(any(feature = "v0_1_15", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
unsafe impl<'a> FromValue<'a> for NominationMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v0_1_15", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
impl ToValue for NominationMode {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NiceProxyType")]
pub enum ProxyType {
    #[doc(alias = "NICE_PROXY_TYPE_NONE")]
    None,
    #[doc(alias = "NICE_PROXY_TYPE_SOCKS5")]
    Socks5,
    #[doc(alias = "NICE_PROXY_TYPE_HTTP")]
    Http,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ProxyType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "ProxyType::{}", match *self {
            Self::None => "None",
            Self::Socks5 => "Socks5",
            Self::Http => "Http",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for ProxyType {
    type GlibType = ffi::NiceProxyType;

    fn into_glib(self) -> ffi::NiceProxyType {
        match self {
            Self::None => ffi::NICE_PROXY_TYPE_NONE,
            Self::Socks5 => ffi::NICE_PROXY_TYPE_SOCKS5,
            Self::Http => ffi::NICE_PROXY_TYPE_HTTP,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NiceProxyType> for ProxyType {
    unsafe fn from_glib(value: ffi::NiceProxyType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Self::None,
            1 => Self::Socks5,
            2 => Self::Http,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for ProxyType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nice_proxy_type_get_type()) }
    }
}

impl glib::value::ValueType for ProxyType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ProxyType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ProxyType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "NiceRelayType")]
pub enum RelayType {
    #[doc(alias = "NICE_RELAY_TYPE_TURN_UDP")]
    Udp,
    #[doc(alias = "NICE_RELAY_TYPE_TURN_TCP")]
    Tcp,
    #[doc(alias = "NICE_RELAY_TYPE_TURN_TLS")]
    Tls,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for RelayType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "RelayType::{}", match *self {
            Self::Udp => "Udp",
            Self::Tcp => "Tcp",
            Self::Tls => "Tls",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for RelayType {
    type GlibType = ffi::NiceRelayType;

    fn into_glib(self) -> ffi::NiceRelayType {
        match self {
            Self::Udp => ffi::NICE_RELAY_TYPE_TURN_UDP,
            Self::Tcp => ffi::NICE_RELAY_TYPE_TURN_TCP,
            Self::Tls => ffi::NICE_RELAY_TYPE_TURN_TLS,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::NiceRelayType> for RelayType {
    unsafe fn from_glib(value: ffi::NiceRelayType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Self::Udp,
            1 => Self::Tcp,
            2 => Self::Tls,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for RelayType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::nice_relay_type_get_type()) }
    }
}

impl glib::value::ValueType for RelayType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for RelayType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for RelayType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

