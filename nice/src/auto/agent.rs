// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

#[cfg(any(feature = "v0_1_15", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
use crate::AgentOption;
use crate::Compatibility;
#[cfg(any(feature = "v0_1_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_8")))]
use crate::ComponentState;
#[cfg(any(feature = "v0_1_15", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
use crate::NominationMode;
use crate::RelayType;
use glib::object::ObjectType as ObjectType_;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::StaticType;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;
use std::ptr;

glib::glib_wrapper! {
    pub struct Agent(Object<ffi::NiceAgent, ffi::NiceAgentClass>);

    match fn {
        get_type => || ffi::nice_agent_get_type(),
    }
}

impl Agent {
    #[doc(alias = "nice_agent_new")]
    pub fn new(ctx: &glib::MainContext, compat: Compatibility) -> Agent {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::nice_agent_new(ctx.to_glib_none().0, compat.to_glib()))
        }
    }

    #[cfg(any(feature = "v0_1_15", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
    #[doc(alias = "nice_agent_new_full")]
    pub fn new_full(ctx: &glib::MainContext, compat: Compatibility, flags: AgentOption) -> Agent {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::nice_agent_new_full(ctx.to_glib_none().0, compat.to_glib(), flags.to_glib()))
        }
    }

    #[doc(alias = "nice_agent_new_reliable")]
    pub fn new_reliable(ctx: &glib::MainContext, compat: Compatibility) -> Agent {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::nice_agent_new_reliable(ctx.to_glib_none().0, compat.to_glib()))
        }
    }

    //#[doc(alias = "nice_agent_add_local_address")]
    //pub fn add_local_address(&self, addr: /*Ignored*/&mut Address) -> bool {
    //    unsafe { TODO: call ffi:nice_agent_add_local_address() }
    //}

    #[doc(alias = "nice_agent_add_stream")]
    pub fn add_stream(&self, n_components: u32) -> u32 {
        unsafe {
            ffi::nice_agent_add_stream(self.to_glib_none().0, n_components)
        }
    }

    #[doc(alias = "nice_agent_attach_recv")]
    pub fn attach_recv<P: Fn(&Agent, u32, u32, u32, &str) + Send + Sync + 'static>(&self, stream_id: u32, component_id: u32, ctx: &glib::MainContext, func: P) -> bool {
        let func_data: Box_<P> = Box_::new(func);
        unsafe extern "C" fn func_func<P: Fn(&Agent, u32, u32, u32, &str) + Send + Sync + 'static>(agent: *mut ffi::NiceAgent, stream_id: libc::c_uint, component_id: libc::c_uint, len: libc::c_uint, buf: *mut libc::c_char, user_data: glib::ffi::gpointer) {
            let agent = from_glib_borrow(agent);
            let buf: Borrowed<glib::GString> = from_glib_borrow(buf);
            let callback: &P = &*(user_data as *mut _);
            (*callback)(&agent, stream_id, component_id, len, buf.as_str());
        }
        let func = Some(func_func::<P> as _);
        let super_callback0: Box_<P> = func_data;
        unsafe {
            from_glib(ffi::nice_agent_attach_recv(self.to_glib_none().0, stream_id, component_id, ctx.to_glib_none().0, func, Box_::into_raw(super_callback0) as *mut _))
        }
    }

    //#[cfg(any(feature = "v0_1_16", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_16")))]
    //#[doc(alias = "nice_agent_close_async")]
    //pub fn close_async<P: FnOnce(Result<(), glib::Error>) + 'static>(&self, callback: P) {
    //    unsafe { TODO: call ffi:nice_agent_close_async() }
    //}

    #[cfg(any(feature = "v0_1_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_6")))]
    #[doc(alias = "nice_agent_forget_relays")]
    pub fn forget_relays(&self, stream_id: u32, component_id: u32) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_forget_relays(self.to_glib_none().0, stream_id, component_id))
        }
    }

    #[doc(alias = "nice_agent_gather_candidates")]
    pub fn gather_candidates(&self, stream_id: u32) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_gather_candidates(self.to_glib_none().0, stream_id))
        }
    }

    //#[cfg(any(feature = "v0_1_4", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_4")))]
    //#[doc(alias = "nice_agent_generate_local_candidate_sdp")]
    //pub fn generate_local_candidate_sdp(&self, candidate: /*Ignored*/&mut Candidate) -> Option<glib::GString> {
    //    unsafe { TODO: call ffi:nice_agent_generate_local_candidate_sdp() }
    //}

    #[cfg(any(feature = "v0_1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_4")))]
    #[doc(alias = "nice_agent_generate_local_sdp")]
    pub fn generate_local_sdp(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::nice_agent_generate_local_sdp(self.to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v0_1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_4")))]
    #[doc(alias = "nice_agent_generate_local_stream_sdp")]
    pub fn generate_local_stream_sdp(&self, stream_id: u32, include_non_ice: bool) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::nice_agent_generate_local_stream_sdp(self.to_glib_none().0, stream_id, include_non_ice.to_glib()))
        }
    }

    #[cfg(any(feature = "v0_1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_8")))]
    #[doc(alias = "nice_agent_get_component_state")]
    pub fn get_component_state(&self, stream_id: u32, component_id: u32) -> ComponentState {
        unsafe {
            from_glib(ffi::nice_agent_get_component_state(self.to_glib_none().0, stream_id, component_id))
        }
    }

    //#[doc(alias = "nice_agent_get_default_local_candidate")]
    //pub fn get_default_local_candidate(&self, stream_id: u32, component_id: u32) -> /*Ignored*/Option<Candidate> {
    //    unsafe { TODO: call ffi:nice_agent_get_default_local_candidate() }
    //}

    #[cfg(any(feature = "v0_1_5", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_5")))]
    #[doc(alias = "nice_agent_get_io_stream")]
    pub fn get_io_stream(&self, stream_id: u32, component_id: u32) -> Option<gio::IOStream> {
        unsafe {
            from_glib_full(ffi::nice_agent_get_io_stream(self.to_glib_none().0, stream_id, component_id))
        }
    }

    //#[doc(alias = "nice_agent_get_local_candidates")]
    //pub fn get_local_candidates(&self, stream_id: u32, component_id: u32) -> /*Ignored*/Vec<Candidate> {
    //    unsafe { TODO: call ffi:nice_agent_get_local_candidates() }
    //}

    #[doc(alias = "nice_agent_get_local_credentials")]
    pub fn get_local_credentials(&self, stream_id: u32) -> Option<(glib::GString, glib::GString)> {
        unsafe {
            let mut ufrag = ptr::null_mut();
            let mut pwd = ptr::null_mut();
            let ret = from_glib(ffi::nice_agent_get_local_credentials(self.to_glib_none().0, stream_id, &mut ufrag, &mut pwd));
            if ret { Some((from_glib_full(ufrag), from_glib_full(pwd))) } else { None }
        }
    }

    //#[doc(alias = "nice_agent_get_remote_candidates")]
    //pub fn get_remote_candidates(&self, stream_id: u32, component_id: u32) -> /*Ignored*/Vec<Candidate> {
    //    unsafe { TODO: call ffi:nice_agent_get_remote_candidates() }
    //}

    //#[doc(alias = "nice_agent_get_selected_pair")]
    //pub fn get_selected_pair(&self, stream_id: u32, component_id: u32, local: /*Ignored*/&mut Candidate, remote: /*Ignored*/&mut Candidate) -> bool {
    //    unsafe { TODO: call ffi:nice_agent_get_selected_pair() }
    //}

    #[cfg(any(feature = "v0_1_5", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_5")))]
    #[doc(alias = "nice_agent_get_selected_socket")]
    pub fn get_selected_socket(&self, stream_id: u32, component_id: u32) -> Option<gio::Socket> {
        unsafe {
            from_glib_full(ffi::nice_agent_get_selected_socket(self.to_glib_none().0, stream_id, component_id))
        }
    }

    #[cfg(any(feature = "v0_1_17", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_17")))]
    #[doc(alias = "nice_agent_get_sockets")]
    pub fn get_sockets(&self, stream_id: u32, component_id: u32) -> Vec<gio::Socket> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::nice_agent_get_sockets(self.to_glib_none().0, stream_id, component_id))
        }
    }

    #[cfg(any(feature = "v0_1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_4")))]
    #[doc(alias = "nice_agent_get_stream_name")]
    pub fn get_stream_name(&self, stream_id: u32) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::nice_agent_get_stream_name(self.to_glib_none().0, stream_id))
        }
    }

    //#[cfg(any(feature = "v0_1_4", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_4")))]
    //#[doc(alias = "nice_agent_parse_remote_candidate_sdp")]
    //pub fn parse_remote_candidate_sdp(&self, stream_id: u32, sdp: &str) -> /*Ignored*/Option<Candidate> {
    //    unsafe { TODO: call ffi:nice_agent_parse_remote_candidate_sdp() }
    //}

    #[cfg(any(feature = "v0_1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_4")))]
    #[doc(alias = "nice_agent_parse_remote_sdp")]
    pub fn parse_remote_sdp(&self, sdp: &str) -> i32 {
        unsafe {
            ffi::nice_agent_parse_remote_sdp(self.to_glib_none().0, sdp.to_glib_none().0)
        }
    }

    //#[cfg(any(feature = "v0_1_4", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_4")))]
    //#[doc(alias = "nice_agent_parse_remote_stream_sdp")]
    //pub fn parse_remote_stream_sdp(&self, stream_id: u32, sdp: &str, ufrag: &str, pwd: &str) -> /*Ignored*/Vec<Candidate> {
    //    unsafe { TODO: call ffi:nice_agent_parse_remote_stream_sdp() }
    //}

    #[cfg(any(feature = "v0_1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_16")))]
    #[doc(alias = "nice_agent_peer_candidate_gathering_done")]
    pub fn peer_candidate_gathering_done(&self, stream_id: u32) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_peer_candidate_gathering_done(self.to_glib_none().0, stream_id))
        }
    }

    //#[cfg(any(feature = "v0_1_5", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_5")))]
    //#[doc(alias = "nice_agent_recv_messages")]
    //pub fn recv_messages<P: IsA<gio::Cancellable>>(&self, stream_id: u32, component_id: u32, messages: /*Ignored*/Vec<InputMessage>, cancellable: Option<&P>) -> Result<(i32, u32), glib::Error> {
    //    unsafe { TODO: call ffi:nice_agent_recv_messages() }
    //}

    //#[cfg(any(feature = "v0_1_5", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_5")))]
    //#[doc(alias = "nice_agent_recv_messages_nonblocking")]
    //pub fn recv_messages_nonblocking<P: IsA<gio::Cancellable>>(&self, stream_id: u32, component_id: u32, messages: /*Ignored*/Vec<InputMessage>, cancellable: Option<&P>) -> Result<(i32, u32), glib::Error> {
    //    unsafe { TODO: call ffi:nice_agent_recv_messages_nonblocking() }
    //}

    #[doc(alias = "nice_agent_remove_stream")]
    pub fn remove_stream(&self, stream_id: u32) {
        unsafe {
            ffi::nice_agent_remove_stream(self.to_glib_none().0, stream_id);
        }
    }

    #[doc(alias = "nice_agent_restart")]
    pub fn restart(&self) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_restart(self.to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v0_1_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_6")))]
    #[doc(alias = "nice_agent_restart_stream")]
    pub fn restart_stream(&self, stream_id: u32) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_restart_stream(self.to_glib_none().0, stream_id))
        }
    }

    #[doc(alias = "nice_agent_send")]
    pub fn send(&self, stream_id: u32, component_id: u32, len: u32, buf: &str) -> i32 {
        unsafe {
            ffi::nice_agent_send(self.to_glib_none().0, stream_id, component_id, len, buf.to_glib_none().0)
        }
    }

    //#[cfg(any(feature = "v0_1_5", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_5")))]
    //#[doc(alias = "nice_agent_send_messages_nonblocking")]
    //pub fn send_messages_nonblocking<P: IsA<gio::Cancellable>>(&self, stream_id: u32, component_id: u32, messages: /*Ignored*/&[&OutputMessage], cancellable: Option<&P>) -> Result<i32, glib::Error> {
    //    unsafe { TODO: call ffi:nice_agent_send_messages_nonblocking() }
    //}

    #[doc(alias = "nice_agent_set_local_credentials")]
    pub fn set_local_credentials(&self, stream_id: u32, ufrag: &str, pwd: &str) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_set_local_credentials(self.to_glib_none().0, stream_id, ufrag.to_glib_none().0, pwd.to_glib_none().0))
        }
    }

    #[doc(alias = "nice_agent_set_port_range")]
    pub fn set_port_range(&self, stream_id: u32, component_id: u32, min_port: u32, max_port: u32) {
        unsafe {
            ffi::nice_agent_set_port_range(self.to_glib_none().0, stream_id, component_id, min_port, max_port);
        }
    }

    #[doc(alias = "nice_agent_set_relay_info")]
    pub fn set_relay_info(&self, stream_id: u32, component_id: u32, server_ip: &str, server_port: u32, username: &str, password: &str, type_: RelayType) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_set_relay_info(self.to_glib_none().0, stream_id, component_id, server_ip.to_glib_none().0, server_port, username.to_glib_none().0, password.to_glib_none().0, type_.to_glib()))
        }
    }

    //#[doc(alias = "nice_agent_set_remote_candidates")]
    //pub fn set_remote_candidates(&self, stream_id: u32, component_id: u32, candidates: /*Ignored*/&[&Candidate]) -> i32 {
    //    unsafe { TODO: call ffi:nice_agent_set_remote_candidates() }
    //}

    #[doc(alias = "nice_agent_set_remote_credentials")]
    pub fn set_remote_credentials(&self, stream_id: u32, ufrag: &str, pwd: &str) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_set_remote_credentials(self.to_glib_none().0, stream_id, ufrag.to_glib_none().0, pwd.to_glib_none().0))
        }
    }

    #[doc(alias = "nice_agent_set_selected_pair")]
    pub fn set_selected_pair(&self, stream_id: u32, component_id: u32, lfoundation: &str, rfoundation: &str) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_set_selected_pair(self.to_glib_none().0, stream_id, component_id, lfoundation.to_glib_none().0, rfoundation.to_glib_none().0))
        }
    }

    //#[doc(alias = "nice_agent_set_selected_remote_candidate")]
    //pub fn set_selected_remote_candidate(&self, stream_id: u32, component_id: u32, candidate: /*Ignored*/&mut Candidate) -> bool {
    //    unsafe { TODO: call ffi:nice_agent_set_selected_remote_candidate() }
    //}

    #[doc(alias = "nice_agent_set_software")]
    pub fn set_software(&self, software: &str) {
        unsafe {
            ffi::nice_agent_set_software(self.to_glib_none().0, software.to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_1_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_4")))]
    #[doc(alias = "nice_agent_set_stream_name")]
    pub fn set_stream_name(&self, stream_id: u32, name: &str) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_set_stream_name(self.to_glib_none().0, stream_id, name.to_glib_none().0))
        }
    }

    #[doc(alias = "nice_agent_set_stream_tos")]
    pub fn set_stream_tos(&self, stream_id: u32, tos: i32) {
        unsafe {
            ffi::nice_agent_set_stream_tos(self.to_glib_none().0, stream_id, tos);
        }
    }

    #[cfg(any(feature = "v0_1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_8")))]
    pub fn get_property_bytestream_tcp(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"bytestream-tcp\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `bytestream-tcp` getter").unwrap()
        }
    }

    pub fn get_property_compatibility(&self) -> u32 {
        unsafe {
            let mut value = glib::Value::from_type(<u32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"compatibility\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `compatibility` getter").unwrap()
        }
    }

    pub fn get_property_controlling_mode(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"controlling-mode\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `controlling-mode` getter").unwrap()
        }
    }

    pub fn set_property_controlling_mode(&self, controlling_mode: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"controlling-mode\0".as_ptr() as *const _, glib::Value::from(&controlling_mode).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_1_14", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_14")))]
    pub fn get_property_force_relay(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"force-relay\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `force-relay` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v0_1_14", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_14")))]
    pub fn set_property_force_relay(&self, force_relay: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"force-relay\0".as_ptr() as *const _, glib::Value::from(&force_relay).to_glib_none().0);
        }
    }

    pub fn get_property_full_mode(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"full-mode\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `full-mode` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v0_1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_8")))]
    pub fn get_property_ice_tcp(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"ice-tcp\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `ice-tcp` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v0_1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_8")))]
    pub fn set_property_ice_tcp(&self, ice_tcp: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"ice-tcp\0".as_ptr() as *const _, glib::Value::from(&ice_tcp).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_16")))]
    pub fn get_property_ice_trickle(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"ice-trickle\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `ice-trickle` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v0_1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_16")))]
    pub fn set_property_ice_trickle(&self, ice_trickle: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"ice-trickle\0".as_ptr() as *const _, glib::Value::from(&ice_trickle).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_8")))]
    pub fn get_property_ice_udp(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"ice-udp\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `ice-udp` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v0_1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_8")))]
    pub fn set_property_ice_udp(&self, ice_udp: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"ice-udp\0".as_ptr() as *const _, glib::Value::from(&ice_udp).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_1_17", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_17")))]
    pub fn get_property_idle_timeout(&self) -> u32 {
        unsafe {
            let mut value = glib::Value::from_type(<u32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"idle-timeout\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `idle-timeout` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v0_1_17", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_17")))]
    pub fn set_property_idle_timeout(&self, idle_timeout: u32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"idle-timeout\0".as_ptr() as *const _, glib::Value::from(&idle_timeout).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_8")))]
    pub fn get_property_keepalive_conncheck(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"keepalive-conncheck\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `keepalive-conncheck` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v0_1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_8")))]
    pub fn set_property_keepalive_conncheck(&self, keepalive_conncheck: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"keepalive-conncheck\0".as_ptr() as *const _, glib::Value::from(&keepalive_conncheck).to_glib_none().0);
        }
    }

    //pub fn get_property_main_context(&self) -> /*Unimplemented*/Fundamental: Pointer {
    //    unsafe {
    //        let mut value = glib::Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"main-context\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `main-context` getter").unwrap()
    //    }
    //}

    pub fn get_property_max_connectivity_checks(&self) -> u32 {
        unsafe {
            let mut value = glib::Value::from_type(<u32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"max-connectivity-checks\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `max-connectivity-checks` getter").unwrap()
        }
    }

    pub fn set_property_max_connectivity_checks(&self, max_connectivity_checks: u32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"max-connectivity-checks\0".as_ptr() as *const _, glib::Value::from(&max_connectivity_checks).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_1_15", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
    pub fn get_property_nomination_mode(&self) -> NominationMode {
        unsafe {
            let mut value = glib::Value::from_type(<NominationMode as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"nomination-mode\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `nomination-mode` getter").unwrap()
        }
    }

    pub fn get_property_proxy_ip(&self) -> Option<glib::GString> {
        unsafe {
            let mut value = glib::Value::from_type(<glib::GString as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"proxy-ip\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `proxy-ip` getter")
        }
    }

    pub fn set_property_proxy_ip(&self, proxy_ip: Option<&str>) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"proxy-ip\0".as_ptr() as *const _, glib::Value::from(proxy_ip).to_glib_none().0);
        }
    }

    pub fn get_property_proxy_password(&self) -> Option<glib::GString> {
        unsafe {
            let mut value = glib::Value::from_type(<glib::GString as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"proxy-password\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `proxy-password` getter")
        }
    }

    pub fn set_property_proxy_password(&self, proxy_password: Option<&str>) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"proxy-password\0".as_ptr() as *const _, glib::Value::from(proxy_password).to_glib_none().0);
        }
    }

    pub fn get_property_proxy_port(&self) -> u32 {
        unsafe {
            let mut value = glib::Value::from_type(<u32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"proxy-port\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `proxy-port` getter").unwrap()
        }
    }

    pub fn set_property_proxy_port(&self, proxy_port: u32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"proxy-port\0".as_ptr() as *const _, glib::Value::from(&proxy_port).to_glib_none().0);
        }
    }

    pub fn get_property_proxy_type(&self) -> u32 {
        unsafe {
            let mut value = glib::Value::from_type(<u32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"proxy-type\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `proxy-type` getter").unwrap()
        }
    }

    pub fn set_property_proxy_type(&self, proxy_type: u32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"proxy-type\0".as_ptr() as *const _, glib::Value::from(&proxy_type).to_glib_none().0);
        }
    }

    pub fn get_property_proxy_username(&self) -> Option<glib::GString> {
        unsafe {
            let mut value = glib::Value::from_type(<glib::GString as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"proxy-username\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `proxy-username` getter")
        }
    }

    pub fn set_property_proxy_username(&self, proxy_username: Option<&str>) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"proxy-username\0".as_ptr() as *const _, glib::Value::from(proxy_username).to_glib_none().0);
        }
    }

    pub fn get_property_reliable(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"reliable\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `reliable` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v0_1_15", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
    pub fn get_property_stun_initial_timeout(&self) -> u32 {
        unsafe {
            let mut value = glib::Value::from_type(<u32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"stun-initial-timeout\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `stun-initial-timeout` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v0_1_15", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
    pub fn set_property_stun_initial_timeout(&self, stun_initial_timeout: u32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"stun-initial-timeout\0".as_ptr() as *const _, glib::Value::from(&stun_initial_timeout).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_1_15", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
    pub fn get_property_stun_max_retransmissions(&self) -> u32 {
        unsafe {
            let mut value = glib::Value::from_type(<u32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"stun-max-retransmissions\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `stun-max-retransmissions` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v0_1_15", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
    pub fn set_property_stun_max_retransmissions(&self, stun_max_retransmissions: u32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"stun-max-retransmissions\0".as_ptr() as *const _, glib::Value::from(&stun_max_retransmissions).to_glib_none().0);
        }
    }

    pub fn get_property_stun_pacing_timer(&self) -> u32 {
        unsafe {
            let mut value = glib::Value::from_type(<u32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"stun-pacing-timer\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `stun-pacing-timer` getter").unwrap()
        }
    }

    pub fn set_property_stun_pacing_timer(&self, stun_pacing_timer: u32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"stun-pacing-timer\0".as_ptr() as *const _, glib::Value::from(&stun_pacing_timer).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v0_1_15", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
    pub fn get_property_stun_reliable_timeout(&self) -> u32 {
        unsafe {
            let mut value = glib::Value::from_type(<u32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"stun-reliable-timeout\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `stun-reliable-timeout` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v0_1_15", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
    pub fn set_property_stun_reliable_timeout(&self, stun_reliable_timeout: u32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"stun-reliable-timeout\0".as_ptr() as *const _, glib::Value::from(&stun_reliable_timeout).to_glib_none().0);
        }
    }

    pub fn get_property_stun_server(&self) -> Option<glib::GString> {
        unsafe {
            let mut value = glib::Value::from_type(<glib::GString as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"stun-server\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `stun-server` getter")
        }
    }

    pub fn set_property_stun_server(&self, stun_server: Option<&str>) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"stun-server\0".as_ptr() as *const _, glib::Value::from(stun_server).to_glib_none().0);
        }
    }

    pub fn get_property_stun_server_port(&self) -> u32 {
        unsafe {
            let mut value = glib::Value::from_type(<u32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"stun-server-port\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `stun-server-port` getter").unwrap()
        }
    }

    pub fn set_property_stun_server_port(&self, stun_server_port: u32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"stun-server-port\0".as_ptr() as *const _, glib::Value::from(&stun_server_port).to_glib_none().0);
        }
    }

    pub fn get_property_support_renomination(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"support-renomination\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `support-renomination` getter").unwrap()
        }
    }

    pub fn set_property_support_renomination(&self, support_renomination: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"support-renomination\0".as_ptr() as *const _, glib::Value::from(&support_renomination).to_glib_none().0);
        }
    }

    pub fn get_property_upnp(&self) -> bool {
        unsafe {
            let mut value = glib::Value::from_type(<bool as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"upnp\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `upnp` getter").unwrap()
        }
    }

    pub fn set_property_upnp(&self, upnp: bool) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"upnp\0".as_ptr() as *const _, glib::Value::from(&upnp).to_glib_none().0);
        }
    }

    pub fn get_property_upnp_timeout(&self) -> u32 {
        unsafe {
            let mut value = glib::Value::from_type(<u32 as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"upnp-timeout\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `upnp-timeout` getter").unwrap()
        }
    }

    pub fn set_property_upnp_timeout(&self, upnp_timeout: u32) {
        unsafe {
            glib::gobject_ffi::g_object_set_property(self.as_ptr() as *mut glib::gobject_ffi::GObject, b"upnp-timeout\0".as_ptr() as *const _, glib::Value::from(&upnp_timeout).to_glib_none().0);
        }
    }

    pub fn connect_candidate_gathering_done<F: Fn(&Agent, u32) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn candidate_gathering_done_trampoline<F: Fn(&Agent, u32) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, stream_id: libc::c_uint, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), stream_id)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"candidate-gathering-done\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(candidate_gathering_done_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    pub fn connect_component_state_changed<F: Fn(&Agent, u32, u32, u32) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn component_state_changed_trampoline<F: Fn(&Agent, u32, u32, u32) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, stream_id: libc::c_uint, component_id: libc::c_uint, state: libc::c_uint, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), stream_id, component_id, state)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"component-state-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(component_state_changed_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    pub fn connect_initial_binding_request_received<F: Fn(&Agent, u32) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn initial_binding_request_received_trampoline<F: Fn(&Agent, u32) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, stream_id: libc::c_uint, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), stream_id)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"initial-binding-request-received\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(initial_binding_request_received_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg_attr(feature = "v0_1_8", deprecated)]
    pub fn connect_new_candidate<F: Fn(&Agent, u32, u32, &str) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn new_candidate_trampoline<F: Fn(&Agent, u32, u32, &str) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, stream_id: libc::c_uint, component_id: libc::c_uint, foundation: *mut libc::c_char, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), stream_id, component_id, &glib::GString::from_glib_borrow(foundation))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"new-candidate\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(new_candidate_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    //#[cfg(any(feature = "v0_1_8", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_8")))]
    //pub fn connect_new_candidate_full<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored candidate: Nice.Candidate
    //}

    #[cfg_attr(feature = "v0_1_8", deprecated)]
    pub fn connect_new_remote_candidate<F: Fn(&Agent, u32, u32, &str) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn new_remote_candidate_trampoline<F: Fn(&Agent, u32, u32, &str) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, stream_id: libc::c_uint, component_id: libc::c_uint, foundation: *mut libc::c_char, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), stream_id, component_id, &glib::GString::from_glib_borrow(foundation))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"new-remote-candidate\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(new_remote_candidate_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    //#[cfg(any(feature = "v0_1_8", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_8")))]
    //pub fn connect_new_remote_candidate_full<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored candidate: Nice.Candidate
    //}

    #[cfg_attr(feature = "v0_1_8", deprecated)]
    pub fn connect_new_selected_pair<F: Fn(&Agent, u32, u32, &str, &str) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn new_selected_pair_trampoline<F: Fn(&Agent, u32, u32, &str, &str) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, stream_id: libc::c_uint, component_id: libc::c_uint, lfoundation: *mut libc::c_char, rfoundation: *mut libc::c_char, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), stream_id, component_id, &glib::GString::from_glib_borrow(lfoundation), &glib::GString::from_glib_borrow(rfoundation))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"new-selected-pair\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(new_selected_pair_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    //#[cfg(any(feature = "v0_1_8", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_8")))]
    //pub fn connect_new_selected_pair_full<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored lcandidate: Nice.Candidate
    //    Ignored rcandidate: Nice.Candidate
    //}

    pub fn connect_reliable_transport_writable<F: Fn(&Agent, u32, u32) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn reliable_transport_writable_trampoline<F: Fn(&Agent, u32, u32) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, stream_id: libc::c_uint, component_id: libc::c_uint, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), stream_id, component_id)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"reliable-transport-writable\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(reliable_transport_writable_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    //#[cfg(any(feature = "v0_1_5", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_5")))]
    //pub fn connect_streams_removed<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Empty ctype stream_ids: *.CArray TypeId { ns_id: 0, id: 15 }
    //}

    #[cfg(any(feature = "v0_1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_8")))]
    pub fn connect_property_bytestream_tcp_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_bytestream_tcp_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::bytestream-tcp\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_bytestream_tcp_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    pub fn connect_property_controlling_mode_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_controlling_mode_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::controlling-mode\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_controlling_mode_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_1_14", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_14")))]
    pub fn connect_property_force_relay_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_force_relay_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::force-relay\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_force_relay_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_8")))]
    pub fn connect_property_ice_tcp_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ice_tcp_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::ice-tcp\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_ice_tcp_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_16")))]
    pub fn connect_property_ice_trickle_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ice_trickle_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::ice-trickle\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_ice_trickle_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_8")))]
    pub fn connect_property_ice_udp_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ice_udp_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::ice-udp\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_ice_udp_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_1_17", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_17")))]
    pub fn connect_property_idle_timeout_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_idle_timeout_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::idle-timeout\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_idle_timeout_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_1_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_8")))]
    pub fn connect_property_keepalive_conncheck_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_keepalive_conncheck_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::keepalive-conncheck\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_keepalive_conncheck_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    pub fn connect_property_max_connectivity_checks_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_max_connectivity_checks_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::max-connectivity-checks\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_max_connectivity_checks_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    pub fn connect_property_proxy_ip_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_proxy_ip_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::proxy-ip\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_proxy_ip_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    pub fn connect_property_proxy_password_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_proxy_password_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::proxy-password\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_proxy_password_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    pub fn connect_property_proxy_port_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_proxy_port_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::proxy-port\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_proxy_port_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    pub fn connect_property_proxy_type_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_proxy_type_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::proxy-type\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_proxy_type_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    pub fn connect_property_proxy_username_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_proxy_username_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::proxy-username\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_proxy_username_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_1_15", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
    pub fn connect_property_stun_initial_timeout_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_stun_initial_timeout_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::stun-initial-timeout\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_stun_initial_timeout_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_1_15", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
    pub fn connect_property_stun_max_retransmissions_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_stun_max_retransmissions_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::stun-max-retransmissions\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_stun_max_retransmissions_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    pub fn connect_property_stun_pacing_timer_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_stun_pacing_timer_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::stun-pacing-timer\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_stun_pacing_timer_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v0_1_15", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v0_1_15")))]
    pub fn connect_property_stun_reliable_timeout_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_stun_reliable_timeout_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::stun-reliable-timeout\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_stun_reliable_timeout_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    pub fn connect_property_stun_server_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_stun_server_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::stun-server\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_stun_server_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    pub fn connect_property_stun_server_port_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_stun_server_port_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::stun-server-port\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_stun_server_port_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    pub fn connect_property_support_renomination_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_support_renomination_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::support-renomination\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_support_renomination_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    pub fn connect_property_upnp_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_upnp_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::upnp\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_upnp_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    pub fn connect_property_upnp_timeout_notify<F: Fn(&Agent) + Send + Sync + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_upnp_timeout_trampoline<F: Fn(&Agent) + Send + Sync + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::upnp-timeout\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_upnp_timeout_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }
}

unsafe impl Send for Agent {}
unsafe impl Sync for Agent {}

impl fmt::Display for Agent {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Agent")
    }
}
